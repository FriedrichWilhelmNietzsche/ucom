#include "stdafx.h"
#include "iSocket.h"

// :CAsyncSocket() 
iSocket::iSocket()
{
	AfxSocketInit();
	// 初始为10个当超过后再动态分配
	nClient.SetSize(0,1);
}


iSocket::~iSocket()
{
}

// 从客户数据列表里面移除
void iSocket::DelFromClient(nSocket *mclient)
{
	int size = nClient.GetSize();
	for (int i = 0; i < size; i++) {
		if (nClient[i] == mclient) {
			delete nClient[i];
			nClient.RemoveAt(i);
			return;
		}
	}
}

// 从客户数据列表里面移除
void iSocket::DelAllClient(void)
{
	int size = nClient.GetSize();
	for (int i = 0; i < size; i++)
	{
		nClient[i]->Close();
		delete nClient[i];
	}

	nClient.RemoveAll();
}

void iSocket::OnReceive(int nErrorCode)
{
	::PostMessage(HWND_BROADCAST, WM_MYONRECVMSG, W_NET_RECV, 0);
	CAsyncSocket::OnReceive(nErrorCode);
}

void iSocket::OnSend(int nErrorCode)
{
	cout << "on send:" << nErrorCode << endl;
	CAsyncSocket::OnSend(nErrorCode);
}

//accept
void iSocket::OnAccept(int nErrorCode) 
{
	cout << "on accept:" << nErrorCode << endl;
	if (!nErrorCode) {
		// 只要有就设置为开启
		isSocketOpen = true;

		//构造一个新的空套接字
		nSocket *sockRecv = new nSocket(hwParent);
		sockRecv->SetSocketHandle(sockRecv);
		//接收连接，若失败删除new的套接字
		if (0 == Accept(*sockRecv)) {
			delete sockRecv;
		}
		else
		{
			::PostMessage(HWND_BROADCAST, WM_MYONRECVMSG, WH_UCOM_SUBNET | WL_UCOM_OPEN, 0);
		}
	}
	CAsyncSocket::OnAccept(nErrorCode);
}

void iSocket::OnConnect(int nErrorCode)
{
	if (nErrorCode == 0) {
		//CString addr;
		//UINT port;
		PostMsgIsOpen(true);
		//GetSockName(addr, port);
		//GetPeerName(addr, port);
		//cout << addr << ',' << port;
	}
	else
	{
		CString errorStr;
		// 发送关闭消息，并关闭
		PostMsgIsOpen(false);
		Close();
		switch (nErrorCode)
		{
		case WSAEADDRINUSE:
			errorStr = _T("地址被占用");break;
		case WSAEADDRNOTAVAIL:
			errorStr = _T("地址本机不可用");break;
		case WSAECONNREFUSED:
			errorStr = _T("连接被拒绝");break;
		case WSAEDESTADDRREQ:
			errorStr = _T("未输入地址");break;
		case WSAEFAULT:
			errorStr = _T("无效地址");break;
		case WSAEINVAL:
			errorStr = _T("无效参数");break;
		case WSAEISCONN:
			errorStr = _T("连接被占用");break;
		case WSAENETUNREACH:
			errorStr = _T("地址不可及"); break;
		case WSAENOBUFS:
			errorStr = _T("套接字内存不足"); break;
		case WSAENOTCONN:
			errorStr = _T("未建立连接\n");break;
		case WSAETIMEDOUT:
			errorStr = _T("建立连接超时"); break;
		default:
			errorStr.Format("错误码-%d", nErrorCode);
			break;
		}
		AfxMessageBox(("连接失败:"+errorStr));
	}
	CAsyncSocket::OnConnect(nErrorCode);
}

void iSocket::OnClose(int nErrorCode)
{
	PostMsgIsOpen(false);
	cout << "o close:" << nErrorCode << endl;
}

void iSocket::PostMsgIsOpen(bool isOpen)
{
	isSocketOpen = isOpen;
	if (isOpen) {
		::PostMessage(HWND_BROADCAST, WM_MYONRECVMSG, WH_UCOM_NET | WL_UCOM_OPEN, 0);
		::SendMessage(hwParent, WM_NETDLG_MSG, WL_UCOM_OPEN, 0);
	}
	else
	{
		::PostMessage(HWND_BROADCAST, WM_MYONRECVMSG, WH_UCOM_NET | WL_UCOM_CLOSE, 0);
		::SendMessage(hwParent, WM_NETDLG_MSG, WL_UCOM_CLOSE, 0);
	}
}

int iSocket::UnblockRead(CString & dataStr)
{
	TCHAR buff[4096];
	int nRead;
	nRead = Receive(buff, 4096);
	cout << "read:" << nRead << ':';
	switch (nRead)
	{
	case 0:
		Close();
		break;
	case SOCKET_ERROR:
		if (GetLastError() != WSAEWOULDBLOCK)
		{
			AfxMessageBox(_T("Socket读取错误!"));
			Close();
		}
		break;
	default:
		dataStr.GetBufferSetLength(nRead);
		memcpy(dataStr.GetBuffer(0), buff, nRead);
		cout << dataStr << endl;
	}
	return nRead;
}


/* nSocket */
nSocket::nSocket(HWND pParent)
{
	hwParent = pParent;
}

nSocket::~nSocket()
{
}

void nSocket::OnReceive(int nErrorCode)
{
	::PostMessage(HWND_BROADCAST, WM_MYONRECVMSG, W_SUBNET_RECV, (LPARAM)&mPara);
	cout << "sub recv" << endl;
}

void nSocket::OnSend(int nErrorCode)
{
	cout << "frist sub send" << endl;
	//第一次连接时候都会有一次send触发，这时候获得ip和端口，关闭send消息触发
	//这权且当连接成功的消息处理
	GetClientInfo();
	AsyncSelect(FD_READ | FD_CONNECT | FD_CLOSE | FD_ACCEPT);
	PostMsgIsOpen(true);
}


void nSocket::OnConnect(int nErrorCode)
{
	cout << "sub connect" << endl;
	PostMsgIsOpen(!nErrorCode);
}

void nSocket::OnClose(int nErrorCode)
{
	cout << "sub close" << endl;
	PostMsgIsOpen(false);
}

void nSocket::GetClientInfo(void)
{
	UINT port;
	GetPeerName(mPara.strIP, port);
	mPara.strIP.Format("%s:%d", mPara.strIP, port);
	cout << "info" << mPara.strIP << endl;
}

void nSocket::PostMsgIsOpen(bool isOpen)
{
	if (isOpen) {
		::SendMessage(hwParent, WM_NETDLG_MSG, W_SUBNET_OPEN, (LPARAM)&mPara);
	}
	else
	{
		::SendMessage(hwParent, WM_NETDLG_MSG, W_SUBNET_CLOSE, (LPARAM)&mPara);
	}
}


int nSocket::UnblockRead(CString & dataStr)
{
	TCHAR buff[4096];
	int nRead;
	nRead = Receive(buff, 4096);
	cout << "read:" << nRead << ':';
	switch (nRead)
	{
	case 0:
		Close();
		break;
	case SOCKET_ERROR:
		if (GetLastError() != WSAEWOULDBLOCK)
		{
			AfxMessageBox(_T("Socket读取错误!"));
			Close();
		}
		break;
	default:
		dataStr.GetBufferSetLength(nRead);
		memcpy(dataStr.GetBuffer(0), buff, nRead);
		cout << dataStr << endl;
	}
	return nRead;
}